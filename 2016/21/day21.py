import sys
import os

def rotate_left(s, steps):
    steps %= len(s)
    return s[steps:] + s[:steps]

def rotate_right(s, steps):
    steps %= len(s)
    return s[-steps:] + s[:-steps]

def swap_pos(s, x, y):
    l = list(s)
    l[x], l[y] = l[y], l[x]
    return "".join(l)

def swap_letter(s, x, y):
    l = list(s)
    ix, iy = l.index(x), l.index(y)
    l[ix], l[iy] = l[iy], l[ix]
    return "".join(l)

def reverse_pos(s, x, y):
    # Inclusive x to y
    l = list(s)
    l[x:y+1] = reversed(l[x:y+1])
    return "".join(l)

def move_pos(s, x, y):
    l = list(s)
    char = l.pop(x)
    l.insert(y, char)
    return "".join(l)

def rotate_based(s, char):
    index = s.index(char)
    rot = 1 + index
    if index >= 4:
        rot += 1
    return rotate_right(s, rot)

def rotate_based_inverse(s, char):
    # Inverse of rotate_based
    # Current index of char
    new_index = s.index(char)
    
    # Map from New Index -> Old Index (verified for len 8)
    # 0->7, 1->0, 2->4, 3->1, 4->5, 5->2, 6->6, 7->3
    # Wait, let's double check map sequence I derived:
    # 0->1, 1->3, 2->5, 3->7, 4->2, 5->4, 6->6, 7->0
    # Map: {1:0, 3:1, 5:2, 7:3, 2:4, 4:5, 6:6, 0:7}
    inverse_map = {
        1: 0,
        3: 1,
        5: 2,
        7: 3,
        2: 4,
        4: 5,
        6: 6,
        0: 7
    }
    
    old_index = inverse_map[new_index]
    # We rotated right by `rot`.
    # rot = (new_index - old_index) % 8 (effectively, though generated by step logic)
    
    rot = (new_index - old_index) % len(s)
    return rotate_left(s, rot)

def scramble(password, lines):
    s = password
    for line in lines:
        if not line.strip(): continue
        tokens = line.strip().split()
        
        if line.startswith("swap position"):
            x, y = int(tokens[2]), int(tokens[5])
            s = swap_pos(s, x, y)
        elif line.startswith("swap letter"):
            x, y = tokens[2], tokens[5]
            s = swap_letter(s, x, y)
        elif line.startswith("rotate left"):
            x = int(tokens[2])
            s = rotate_left(s, x)
        elif line.startswith("rotate right"):
            x = int(tokens[2])
            s = rotate_right(s, x)
        elif line.startswith("rotate based"):
            x = tokens[-1]
            s = rotate_based(s, x)
        elif line.startswith("reverse"):
            x, y = int(tokens[2]), int(tokens[4])
            s = reverse_pos(s, x, y)
        elif line.startswith("move"):
            x, y = int(tokens[2]), int(tokens[5])
            s = move_pos(s, x, y)
            
    return s

def unscramble(password, lines):
    s = password
    # Traverse backwards
    for line in reversed(lines):
        if not line.strip(): continue
        tokens = line.strip().split()
        
        if line.startswith("swap position"):
            x, y = int(tokens[2]), int(tokens[5])
            s = swap_pos(s, x, y) # Symmetric
        elif line.startswith("swap letter"):
            x, y = tokens[2], tokens[5]
            s = swap_letter(s, x, y) # Symmetric
        elif line.startswith("rotate left"):
            x = int(tokens[2])
            s = rotate_right(s, x) # Inverse
        elif line.startswith("rotate right"):
            x = int(tokens[2])
            s = rotate_left(s, x) # Inverse
        elif line.startswith("rotate based"):
            x = tokens[-1]
            s = rotate_based_inverse(s, x) # Special Inverse
        elif line.startswith("reverse"):
            x, y = int(tokens[2]), int(tokens[4])
            s = reverse_pos(s, x, y) # Symmetric
        elif line.startswith("move"):
            x, y = int(tokens[2]), int(tokens[5])
            # Inverse of move x->y is move y->x
            s = move_pos(s, y, x)
            
    return s

def part1():
    input_path = os.path.join(sys.path[0], 'input.txt')
    with open(input_path) as f:
        lines = f.readlines()
    return scramble("abcdefgh", lines)

def part2():
    input_path = os.path.join(sys.path[0], 'input.txt')
    with open(input_path) as f:
        lines = f.readlines()
    return unscramble("fbgdceah", lines)

def run_example():
    instructions = [
        "swap position 4 with position 0",
        "swap letter d with letter b",
        "reverse positions 0 through 4",
        "rotate left 1 step",
        "move position 1 to position 4",
        "move position 3 to position 0",
        "rotate based on position of letter b",
        "rotate based on position of letter d"
    ]
    start = "abcde"
    # Note: inverse based logic assumes len 8. Example is len 5.
    # So unscramble might fail for example unless we adapt map.
    # But forward scramble should match Example result: decab.
    
    scrambled = scramble(start, instructions)
    print(f"Example Scramble 'abcde': {scrambled} (Expected decab)")
    
    # Verify my logic for Day 21 Part 2 (Inverse Map) using len 8 string:
    test_str = "abcdefgh"
    # Apply single rotate based op
    # char 'a' at 0 -> rot 1 -> idx 1.
    s2 = rotate_based(test_str, 'a') # "habcdefg"
    # verify inverse
    s3 = rotate_based_inverse(s2, 'a')
    print(f"Test Inverse 'a': {s2} -> {s3} (Expected {test_str}) -> {'Match' if s3 == test_str else 'Fail'}")
    
    # char 'e' at 4 -> rot 6 -> idx 2.
    s4 = rotate_based(test_str, 'e')
    s5 = rotate_based_inverse(s4, 'e')
    print(f"Test Inverse 'e': {s4} -> {s5} (Expected {test_str}) -> {'Match' if s5 == test_str else 'Fail'}")

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "test":
        run_example()
    else:
        print("Part 1:", part1())
        print("Part 2:", part2())
